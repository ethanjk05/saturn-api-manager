
<!DOCTYPE html>
  <html lang="en">
    <head>
      <!--pain painstakingly made by bleach aka lolinekos-->
      <link rel="icon" href="saturn.png">
      <link rel="shortcut icon" href="saturn.png">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" >
      <meta property="og:title" content="Saturn API"> 
      <meta property="og:url" content="https://2bfy.ltd/"> 
      <meta property="og:image" content="saturn.png">
      <meta property="og:description" content="The best botnet of 2020 is here!!!
      full of cat girls, maids, and cat girl maids."> 
      <meta name="theme-color" content="#FF006C">
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>Saturn API Manager</title>
      <meta
        name="viewport"
        content="width=device-width, minimal-ui, viewport-fit=cover, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"
      />
  </script>
      <link rel="stylesheet" href="./style.css">
      <style>
  @font-face {
      font-family: CaratStd-UB;
      src: url("caratstd-ub.otf") format("opentype");
  }
  
  @font-face {
      font-family: CaratStd-UB;
      font-weight: bold;
      src: url("caratstd-ub.otf") format("opentype");
  }
  *{
     margin: 0px;
     padding: 0px;
  }
  
  .bg_ab{
     background-color: black;
     width: 100%;
     height: 100%;
     opacity: 0.4;
     filter: alpha(opacity=55);
  }
  .bg{
     position: fixed;
     top: 0;
     left: 0;
     min-height: 100%;
     min-width: 100%;
     width: 100%;
     height: 100%;
     height: 100%;
     background-position: center;
     background-repeat: no-repeat;
     background-size: cover;  
  }   
     .bg_ab h1{
     text-align: center;
     padding-top: 15%;
  }
          
     .bg_ab p{
     text-align: center;
     padding-top: 5px;
  }
  .center {
    display: block;
    margin-left: auto;
    margin-right: auto;
    width: 50%;
  }
  
  .container {
    width: 400px;
    height: 400px;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    justify-content: center;
    align-items: center;
  }
  
  .btn {
    width: 180px;
    height: 60px;
    cursor: pointer;
    background: transparent;
    border: 1px solid #FF006C;
    outline: none;
    transition: 1s ease-in-out;
  }
  
  svg {
    position: absolute;
    left: 0;
    top: 0;
    fill: none;
    stroke: #fff;
    stroke-dasharray: 150 480;
    stroke-dashoffset: 150;
    transition: 1s ease-in-out;
  }
  
  .btn:hover {
    transition: 1s ease-in-out;
    background: #FF006C;
  }
  
  .btn:hover svg {
    stroke-dashoffset: -480;
  }
  
  .btn span {
    color: white;
    font-size: 18px;
    font-weight: 100;
  }
  .brk-btn {
    position: relative;
    background: none;
    color: #FF006C;
    text-transform: uppercase;
    text-decoration: none;
    border: 0.2em solid #FF006C;
    padding: 0.5em 1em;
    &::before {
      content: "";
      display: block;
      position: absolute;
      width: 10%;
      background: #222;
      height: 0.3em;
      right: 20%;
      top: -0.21em;
      transform: skewX(-45deg);
      -webkit-transition: all 0.45s cubic-bezier(0.86, 0, 0.07, 1);
      transition: all 0.45s cubic-bezier(0.86, 0, 0.07, 1);
    }
    &::after {
      content: "";
      display: block;
      position: absolute;
      width: 10%;
      background: #222;
      height: 0.3em;
      left: 20%;
      bottom: -0.25em;
      transform: skewX(45deg);
      -webkit-transition: all 0.45 cubic-bezier(0.86, 0, 0.07, 1);
      transition: all 0.45s cubic-bezier(0.86, 0, 0.07, 1);
    }
    &:hover {
      &::before {
        right: 80%;
      }
      &::after {
        left: 80%;
      }
    }
  }
  gradientl {
     background: linear-gradient( to left, #FF0040, #FF008A, #FF00BF, #FF00F3); 
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  gradientr {
     background: linear-gradient( to right, #FF0040, #FF008A, #FF00BF, #FF00F3); 
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  </style>
  
  <script type="application/javascript" src="https://api.ipify.org?format=jsonp&callback=getIP"></script>
  
  </head>
  <title>Saturn API</title>
  <body text="#FF006C">
        <div class="bg">
          <br><br><br><br><center><img src="" alt="">
          <br><img src="ninja.png" alt="nekopic"><br><gradientl>
          <br>New Saturn API Manager<br><br></gradientl>
          <a href="hmethods.php" class="brk-btn"><gradientr>Home Methods</gradientr></a>
          <a href="bmethods.php" class="brk-btn"><gradientr>Bypass Methods</gradientr></a>
	  <a href="proxies.php" class="brk-btn"><gradientr>Proxy Servers</gradientr></a>
	  <a href="https://discord.gg/EhzAVV3JRE" class="brk-btn"><gradientr>Discord Server</gradientr></a>
    <script src= 
  "https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"> 
      </script>
      <audio autoplay loop playsinline id="music"> 
    <source src="blood.mp3">
  </audio>
  <!-- partial -->
    <script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script><script  src="./script1.js"></script>
      <script type="module">
        import {
          Polyline,
          Renderer,
          Transform,
          Geometry,
          Program,
          Mesh,
          Vec3,
          Vec2,
          Color
        } from "https://cdn.jsdelivr.net/npm/ogl@0.0.32/dist/ogl.mjs";
  
        const vertex = `
              attribute vec3 position;
              attribute vec3 next;
              attribute vec3 prev;
              attribute vec2 uv;
              attribute float side;
  
              uniform vec2 uResolution;
              uniform float uDPR;
              uniform float uThickness;
  
              vec4 getPosition() {
                  vec2 aspect = vec2(uResolution.x / uResolution.y, 1);
                  vec2 nextScreen = next.xy * aspect;
                  vec2 prevScreen = prev.xy * aspect;
  
                  vec2 tangent = normalize(nextScreen - prevScreen);
                  vec2 normal = vec2(-tangent.y, tangent.x);
                  normal /= aspect;
                  normal *= 1.0 - pow(abs(uv.y - 0.5) * 1.9, 2.0);
  
                  float pixelWidth = 1.0 / (uResolution.y / uDPR);
                  normal *= pixelWidth * uThickness;
  
                  // When the points are on top of each other, shrink the line to avoid artifacts.
                  float dist = length(nextScreen - prevScreen);
                  normal *= smoothstep(0.0, 0.02, dist);
  
                  vec4 current = vec4(position, 1);
                  current.xy -= normal * side;
                  return current;
              }
  
              void main() {
                  gl_Position = getPosition();
              }
          `;
  
        {
          const renderer = new Renderer({ dpr: 2 });
          const gl = renderer.gl;
          document.body.appendChild(gl.canvas)
          gl.clearColor(0.1, 0.1, 0.1, 1);
  
          const scene = new Transform();
  
          const lines = [];
  
          function resize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
  
            // We call resize on the polylines to update their resolution uniforms
            lines.forEach(line => line.polyline.resize());
          }
          window.addEventListener("resize", resize, false);
  
          // If you're interested in learning about drawing lines with geometry,
          // go through this detailed article by Matt DesLauriers
          // https://mattdesl.svbtle.com/drawing-lines-is-hard
          // It's an excellent breakdown of the approaches and their pitfalls.
  
          // In this example, we're making screen-space polylines. Basically it
          // involves creating a geometry of vertices along a path - with two vertices
          // at each point. Then in the vertex shader, we push each pair apart to
          // give the line some width.
  
          // Just a helper function to make the code neater
          function random(a, b) {
            const alpha = Math.random();
            return a * (1.0 - alpha) + b * alpha;
          }
  
          // We're going to make a number of different coloured lines for fun.
          ["#FC1EAF", "#FE1E9C", "#676767", "#FF0770","#FC1E9E","#FC1EC3"].forEach(
            (color, i) => {
              // Store a few values for each lines' randomised spring movement
              const line = {
                spring: random(0.02, 0.1),
                friction: random(0.7, 0.95),
                mouseVelocity: new Vec3(),
                mouseOffset: new Vec3(random(-1, 1) * 0.02)
              };
  
              // Create an array of Vec3s (eg [[0, 0, 0], ...])
              const count = 20;
              const points = (line.points = []);
              for (let i = 0; i < count; i++) points.push(new Vec3());
  
              line.polyline = new Polyline(gl, {
                points,
                vertex,
                uniforms: {
                  uColor: { value: new Color(color) },
                  uThickness: { value: random(20, 50) }
                }
              });
  
              line.polyline.mesh.setParent(scene);
  
              lines.push(line);
            }
          );
  
          // Call initial resize after creating the polylines
          resize();
  
          // Add handlers to get mouse position
          const mouse = new Vec3();
          if ("ontouchstart" in window) {
            window.addEventListener("touchstart", updateMouse, false);
            window.addEventListener("touchmove", updateMouse, false);
          } else {
            window.addEventListener("mousemove", updateMouse, false);
          }
  
          function updateMouse(e) {
            if (e.changedTouches && e.changedTouches.length) {
              e.x = e.changedTouches[0].pageX;
              e.y = e.changedTouches[0].pageY;
            }
            if (e.x === undefined) {
              e.x = e.pageX;
              e.y = e.pageY;
            }
  
            // Get mouse value in -1 to 1 range, with y flipped
            mouse.set(
              (e.x / gl.renderer.width) * 2 - 1,
              (e.y / gl.renderer.height) * -2 + 1,
              0
            );
          }
  
          const tmp = new Vec3();
  
          requestAnimationFrame(update);
          function update(t) {
            requestAnimationFrame(update);
  
            lines.forEach(line => {
              // Update polyline input points
              for (let i = line.points.length - 1; i >= 0; i--) {
                if (!i) {
                  // For the first point, spring ease it to the mouse position
                  tmp
                    .copy(mouse)
                    .add(line.mouseOffset)
                    .sub(line.points[i])
                    .multiply(line.spring);
                  line.mouseVelocity.add(tmp).multiply(line.friction);
                  line.points[i].add(line.mouseVelocity);
                } else {
                  // The rest of the points ease to the point in front of them, making a line
                  line.points[i].lerp(line.points[i - 1], 0.9);
                }
              }
              line.polyline.updateGeometry();
            });
  
            renderer.render({ scene });
          }
        }
      </script>
    </body>
  </html>